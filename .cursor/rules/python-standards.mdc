---
alwaysApply: false
---
# Python Bindings Code Generation Standards

This project provides Python bindings for NanoPDF with focus on performance and Pythonic API design.

## Python Version and Environment

- **Minimum Python Version**: `3.10+`
- **Package Manager**: `uv` (preferred) or `pip`
- **Type Hints**: Required for all public API

## Project Structure

```
nanopdf-py/
├── pyproject.toml          # Project configuration
├── src/
│   └── nanopdf/
│       ├── __init__.py     # Package exports
│       ├── buffer.py       # Buffer implementation
│       ├── geometry.py     # Point, Rect, Matrix, Quad
│       ├── document.py     # PDF document operations
│       ├── _native.py      # FFI bindings (cffi/ctypes)
│       └── py.typed        # PEP 561 marker
├── tests/
│   ├── conftest.py         # Pytest fixtures
│   ├── test_buffer.py
│   └── test_geometry.py
└── README.md
```

## Type Hints

### Always Use Type Annotations

```python
# ✅ CORRECT: Full type annotations
from typing import Optional, Union, Sequence

class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

    def transform(self, matrix: 'Matrix') -> 'Point':
        return Point(
            self.x * matrix.a + self.y * matrix.c + matrix.e,
            self.x * matrix.b + self.y * matrix.d + matrix.f
        )

    def distance(self, other: 'Point') -> float:
        dx = self.x - other.x
        dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5


# ❌ WRONG: Missing type hints
class Point:
    def __init__(self, x, y):  # No type hints!
        self.x = x
        self.y = y
```

### Use `__slots__` for Performance

```python
# ✅ CORRECT: Use __slots__ for geometry types
class Rect:
    __slots__ = ('x0', 'y0', 'x1', 'y1')

    def __init__(self, x0: float, y0: float, x1: float, y1: float) -> None:
        self.x0 = x0
        self.y0 = y0
        self.x1 = x1
        self.y1 = y1


# ❌ WRONG: No __slots__ (wastes memory for many instances)
class Rect:
    def __init__(self, x0: float, y0: float, x1: float, y1: float) -> None:
        self.x0 = x0
        self.y0 = y0
        self.x1 = x1
        self.y1 = y1
```

## Performance Optimizations

### Pure Python Fast Paths

```python
# ✅ CORRECT: Use pure Python for simple operations
class Matrix:
    __slots__ = ('a', 'b', 'c', 'd', 'e', 'f')

    # Cache common rotation matrices
    _ROTATION_CACHE: dict[int, 'Matrix'] = {}

    @classmethod
    def identity(cls) -> 'Matrix':
        """Return identity matrix (pure Python, no FFI)."""
        return cls(1.0, 0.0, 0.0, 1.0, 0.0, 0.0)

    @classmethod
    def scale(cls, sx: float, sy: float) -> 'Matrix':
        """Return scale matrix (pure Python, no FFI)."""
        return cls(sx, 0.0, 0.0, sy, 0.0, 0.0)

    @classmethod
    def translate(cls, tx: float, ty: float) -> 'Matrix':
        """Return translation matrix (pure Python, no FFI)."""
        return cls(1.0, 0.0, 0.0, 1.0, tx, ty)

    @classmethod
    def rotate(cls, degrees: float) -> 'Matrix':
        """Return rotation matrix with caching for common angles."""
        int_degrees = int(degrees) % 360

        # Check cache first
        if int_degrees in cls._ROTATION_CACHE and degrees == int_degrees:
            return cls._ROTATION_CACHE[int_degrees]

        # Calculate rotation
        import math
        rad = math.radians(degrees)
        cos_val = math.cos(rad)
        sin_val = math.sin(rad)

        result = cls(cos_val, sin_val, -sin_val, cos_val, 0.0, 0.0)

        # Cache integer angles
        if degrees == int_degrees:
            cls._ROTATION_CACHE[int_degrees] = result

        return result


# ❌ WRONG: Always calling FFI for simple operations
class Matrix:
    @classmethod
    def identity(cls) -> 'Matrix':
        # Unnecessary FFI call overhead!
        return _native.fz_identity_matrix()
```

### In-Place Mutations

```python
# ✅ CORRECT: Provide both immutable and in-place variants
class Point:
    __slots__ = ('x', 'y')

    def transform(self, matrix: 'Matrix') -> 'Point':
        """Return a new transformed point (immutable)."""
        return Point(
            self.x * matrix.a + self.y * matrix.c + matrix.e,
            self.x * matrix.b + self.y * matrix.d + matrix.f
        )

    def transform_inplace(self, matrix: 'Matrix') -> 'Point':
        """Transform this point in place (mutating, returns self)."""
        new_x = self.x * matrix.a + self.y * matrix.c + matrix.e
        new_y = self.x * matrix.b + self.y * matrix.d + matrix.f
        self.x = new_x
        self.y = new_y
        return self
```

### Batch Operations

```python
# ✅ CORRECT: Provide batch operations for efficiency
def transform_points_batch(
    points: Sequence[Point],
    matrix: 'Matrix'
) -> list[Point]:
    """Transform multiple points efficiently."""
    a, b, c, d, e, f = matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f

    return [
        Point(p.x * a + p.y * c + e, p.x * b + p.y * d + f)
        for p in points
    ]

# ✅ CORRECT: NumPy integration when available
def transform_points_numpy(
    points: 'numpy.ndarray',  # Shape: (N, 2)
    matrix: 'Matrix'
) -> 'numpy.ndarray':
    """Transform points using NumPy for bulk operations."""
    import numpy as np

    m = np.array([
        [matrix.a, matrix.c, matrix.e],
        [matrix.b, matrix.d, matrix.f],
        [0.0, 0.0, 1.0]
    ])

    # Add homogeneous coordinate
    ones = np.ones((points.shape[0], 1))
    homogeneous = np.hstack([points, ones])

    # Transform and extract x,y
    transformed = homogeneous @ m.T
    return transformed[:, :2]
```

## FFI Bindings

### Lazy Loading

```python
# ✅ CORRECT: Lazy load FFI only when needed
_ffi = None
_lib = None

def _get_lib():
    """Lazy load the native library."""
    global _ffi, _lib
    if _lib is None:
        from cffi import FFI
        _ffi = FFI()
        _ffi.cdef("""
            // FFI declarations
        """)
        _lib = _ffi.dlopen("libnanopdf.so")
    return _lib


# ❌ WRONG: Loading at module import time
from cffi import FFI
ffi = FFI()
lib = ffi.dlopen("libnanopdf.so")  # Slows down import!
```

### Error Handling

```python
# ✅ CORRECT: Convert FFI errors to Python exceptions
class NanoPdfError(Exception):
    """Base exception for NanoPDF errors."""
    pass

class ParseError(NanoPdfError):
    """Raised when PDF parsing fails."""
    def __init__(self, message: str, offset: int = 0):
        self.offset = offset
        super().__init__(f"Parse error at offset {offset}: {message}")

class ResourceError(NanoPdfError):
    """Raised when a resource operation fails."""
    pass


def _check_error(result: int) -> None:
    """Check FFI result and raise appropriate exception."""
    if result < 0:
        error_msg = _get_lib().nanopdf_get_last_error()
        error_str = _ffi.string(error_msg).decode('utf-8')

        if "parse" in error_str.lower():
            raise ParseError(error_str)
        else:
            raise NanoPdfError(error_str)
```

## Context Managers

```python
# ✅ CORRECT: Use context managers for resource cleanup
from typing import Self

class Document:
    __slots__ = ('_handle', '_closed')

    def __init__(self, handle: int) -> None:
        self._handle = handle
        self._closed = False

    def close(self) -> None:
        """Close the document and release resources."""
        if not self._closed:
            self._closed = True
            _get_lib().nanopdf_close_document(self._handle)

    def __enter__(self) -> Self:
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.close()

    def __del__(self) -> None:
        # Backup cleanup if not properly closed
        self.close()


# Usage
with Document.open("file.pdf") as doc:
    print(doc.page_count)
# Document is automatically closed here
```

## Protocol Classes

```python
# ✅ CORRECT: Use protocols for duck typing
from typing import Protocol, runtime_checkable

@runtime_checkable
class PointLike(Protocol):
    """Protocol for point-like objects."""
    x: float
    y: float

@runtime_checkable
class RectLike(Protocol):
    """Protocol for rect-like objects."""
    x0: float
    y0: float
    x1: float
    y1: float


def contains_point(rect: RectLike, point: PointLike) -> bool:
    """Check if rect contains point (works with any compatible type)."""
    return (rect.x0 <= point.x <= rect.x1 and
            rect.y0 <= point.y <= rect.y1)
```

## Testing

### Use pytest

```python
# ✅ CORRECT: pytest with fixtures
import pytest
from nanopdf import Point, Rect, Matrix

class TestPoint:
    def test_constructor(self) -> None:
        p = Point(10.0, 20.0)
        assert p.x == 10.0
        assert p.y == 20.0

    def test_transform(self) -> None:
        p = Point(1.0, 0.0)
        m = Matrix.rotate(90)
        result = p.transform(m)
        assert result.x == pytest.approx(0.0, abs=1e-10)
        assert result.y == pytest.approx(1.0, abs=1e-10)

    @pytest.mark.parametrize("x,y,expected_dist", [
        (3.0, 4.0, 5.0),
        (0.0, 0.0, 0.0),
        (1.0, 0.0, 1.0),
    ])
    def test_distance_from_origin(
        self, x: float, y: float, expected_dist: float
    ) -> None:
        p = Point(x, y)
        origin = Point(0.0, 0.0)
        assert p.distance(origin) == pytest.approx(expected_dist)


@pytest.fixture
def sample_rect() -> Rect:
    """Fixture providing a sample rectangle."""
    return Rect(0.0, 0.0, 100.0, 100.0)


def test_rect_contains(sample_rect: Rect) -> None:
    assert sample_rect.contains(Point(50.0, 50.0))
    assert not sample_rect.contains(Point(150.0, 50.0))
```

### Benchmarks with pytest-benchmark

```python
# ✅ CORRECT: Performance benchmarks
import pytest

def test_point_transform_performance(benchmark) -> None:
    p = Point(100.0, 200.0)
    m = Matrix.scale(2.0, 2.0)

    result = benchmark(p.transform, m)
    assert result.x == 200.0


def test_matrix_rotate_cached(benchmark) -> None:
    """Benchmark rotation with cache hits."""
    def rotate_90():
        return Matrix.rotate(90)

    # Warm up cache
    Matrix.rotate(90)

    result = benchmark(rotate_90)
    assert result is not None
```

## Documentation

### Docstrings

```python
# ✅ CORRECT: Google-style docstrings
class Buffer:
    """A dynamic byte buffer for efficient binary data handling.

    Buffer provides efficient append, read, and slice operations
    for working with binary data. It automatically grows as needed.

    Attributes:
        length: Current number of bytes in the buffer.
        capacity: Current allocated capacity in bytes.

    Example:
        >>> buf = Buffer(1024)
        >>> buf.append(b"Hello")
        >>> buf.append(b" World")
        >>> bytes(buf)
        b'Hello World'
    """

    def append(self, data: bytes) -> None:
        """Append data to the end of the buffer.

        The buffer will automatically grow if the current capacity
        is insufficient.

        Args:
            data: Bytes to append to the buffer.

        Raises:
            MemoryError: If the buffer cannot be grown.

        Example:
            >>> buf = Buffer()
            >>> buf.append(b"Hello")
            >>> buf.length
            5
        """
        pass
```

## Package Configuration

### pyproject.toml

```toml
[project]
name = "nanopdf"
version = "0.1.0"
description = "High-performance PDF library"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT OR Apache-2.0"}
authors = [{name = "Lexmata", email = "contact@lexmata.com"}]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Rust",
    "Topic :: Software Development :: Libraries",
]
keywords = ["pdf", "document", "parsing"]
dependencies = []

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-benchmark>=4.0",
    "mypy>=1.0",
    "ruff>=0.1",
]
numpy = ["numpy>=1.20"]

[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[tool.maturin]
python-source = "src"
features = ["pyo3/extension-module"]

[tool.mypy]
python_version = "3.10"
strict = true
warn_return_any = true
warn_unused_configs = true

[tool.ruff]
target-version = "py310"
line-length = 100

[tool.ruff.lint]
select = ["E", "F", "W", "I", "N", "UP", "ANN", "B", "C4", "SIM"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
```

## Summary Checklist

- [ ] Type hints on all public functions and methods
- [ ] `__slots__` on all geometry and frequently-instantiated classes
- [ ] Pure Python fast paths for simple operations
- [ ] Rotation matrix caching for common angles
- [ ] In-place mutation variants (`_inplace` suffix)
- [ ] Batch operations for efficiency
- [ ] NumPy integration (optional)
- [ ] Lazy FFI loading
- [ ] Context managers for resources
- [ ] Protocols for duck typing
- [ ] Google-style docstrings
- [ ] pytest with fixtures and parametrize
- [ ] pytest-benchmark for performance tests
- [ ] pyproject.toml with proper configuration
- [ ] mypy strict mode
- [ ] ruff for linting
